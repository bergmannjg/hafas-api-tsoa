import { Controller, Get, Query, Route } from "tsoa";
import createClient = require('hafas-client');
import dbProfile = require('hafas-client/p/db');
import { Stop, Location, Station, Journeys, Alternative } from './hafas-client-types';

@Route("hafas")
export class HafasController extends Controller {
  private clientFactory() { return createClient(dbProfile, 'client'); }

  // the following methods are generated by the script 'generate-controller-methods'

  /**
  * Retrieves locations or stops
  * @param from 
  * @param fuzzy find only exact matches?
  * @param results how many search results?
  * @param stops return stops/stations?
  * @param addresses return addresses
  * @param poi points of interest
  * @param linesOfStops parse & expose lines at each stop/station?
  * @param language Language of the results
  */
  @Get("locations")
  public async getlocations(
    @Query() from: string,
    @Query() fuzzy = true,
    @Query() results = 10,
    @Query() stops = true,
    @Query() addresses = false,
    @Query() poi = true,
    @Query() linesOfStops = false,
    @Query() language = "en",
  ): Promise<Array<Station | Stop | Location>> {
    const client = this.clientFactory();
    return await client.locations(from, { fuzzy, results, stops, addresses, poi, linesOfStops, language }) as Array<Station | Stop | Location>;
  }
  /**
  * Retrieves journeys
  * @param from uid of station
  * @param to uid of station
  * @param departure departure date, undefined corresponds to Date.Now
  * @param results how many search results?
  * @param via let journeys pass this station
  * @param stopovers return stations on the way?
  * @param transfers Maximum nr of transfers. Default: Let HAFAS decide.
  * @param transferTime minimum time for a single transfer in minutes
  * @param accessibility 'none', 'partial' or 'complete'
  * @param bike only bike-friendly journeys
  * @param tickets return tickets? only available with some profiles
  * @param polylines return a shape for each leg?
  * @param remarks parse & expose hints & warnings?
  * @param walkingSpeed 'slow', 'normal', 'fast'
  * @param startWithWalking 
  * @param language language to get results in
  * @param scheduledDays parse which days each journey is valid on
  */
  @Get("journeys")
  public async getjourneys(
    @Query() from: string,
    @Query() to: string,
    @Query() departure = undefined,
    @Query() results = 3,
    @Query() via = undefined,
    @Query() stopovers = false,
    @Query() transfers = 10,
    @Query() transferTime = 10,
    @Query() accessibility = "none",
    @Query() bike = false,
    @Query() tickets = false,
    @Query() polylines = false,
    @Query() remarks = false,
    @Query() walkingSpeed = "slow",
    @Query() startWithWalking = false,
    @Query() language = "en",
    @Query() scheduledDays = false,
  ): Promise<Journeys> {
    const client = this.clientFactory();
    return await client.journeys(from, to, { departure, results, via, stopovers, transfers, transferTime, accessibility, bike, tickets, polylines, remarks, walkingSpeed, startWithWalking, language, scheduledDays }) as Journeys;
  }
  /**
  * Retrieves departures
  * @param station uid of station
  * @param when departure date, undefined corresponds to Date.Now
  * @param direction only show departures heading to this station
  * @param duration show departures for the next n minutes
  * @param results max. number of results; `null` means "whatever HAFAS wants"
  * @param linesOfStops parse & expose lines at the stop/station?
  * @param remarks parse & expose hints & warnings?
  * @param stopovers fetch & parse previous/next stopovers?
  * @param includeRelatedStations departures at related stations
  * @param language language
  */
  @Get("departures")
  public async getdepartures(
    @Query() station: string,
    @Query() when = undefined,
    @Query() direction = undefined,
    @Query() duration = 120,
    @Query() results = 10,
    @Query() linesOfStops = false,
    @Query() remarks = false,
    @Query() stopovers = false,
    @Query() includeRelatedStations = false,
    @Query() language = "en",
  ): Promise<Alternative[]> {
    const client = this.clientFactory();
    return await client.departures(station, { when, direction, duration, results, linesOfStops, remarks, stopovers, includeRelatedStations, language }) as Alternative[];
  }
  /**
  * Retrieves nearby stops
  * @param longitude 
  * @param latitude 
  * @param results 
  * @param distance 
  * @param poi 
  * @param stops 
  * @param linesOfStops 
  * @param language 
  */
  @Get("nearby")
  public async getnearby(
    @Query() longitude: number,
    @Query() latitude: number,
    @Query() results: number,
    @Query() distance: number,
    @Query() poi: boolean,
    @Query() stops: boolean,
    @Query() linesOfStops: boolean,
    @Query() language: string,
  ): Promise<Stop[]> {
    const client = this.clientFactory();
    return await client.nearby({ type: "location", longitude, latitude }, { results, distance, poi, stops, linesOfStops, language }) as Stop[];
  }

}