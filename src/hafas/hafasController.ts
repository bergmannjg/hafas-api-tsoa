import { Controller, Get, Query, Route } from "tsoa";
import { ProfileId, Profile, Stop, Location, Station, Journeys, Radar, TripWithRealtimeData, Departures, DurationsWithRealtimeData, LinesWithRealtimeData } from './hafas-client-types.js';
import { createClient } from 'hafas-client';
import { profile as dbProfile } from 'hafas-client/p/db/index.js';
import { profile as bvgProfile } from 'hafas-client/p/bvg/index.js';
import { profile as oebbProfile } from 'hafas-client/p/oebb/index.js';

const defaultProfile: Profile = {
  locale: "",
  timezone: "",
  endpoint: "",
  products: [],
  trip: false,
  radar: false,
  reachableFrom: true,
  lines: true,
}

const getValue = (p: Profile, getter: (p: Profile) => boolean | undefined): boolean => {
  const v = getter(p);
  return v === undefined ? (getter(defaultProfile) ?? false) : v;
}
@Route("hafas")
export class HafasController extends Controller {
  private getProfile(p?: unknown): Profile { return p === 'bvg' ? bvgProfile : p === 'oebb' ? oebbProfile : dbProfile; }
  private clientFactory(p?: unknown) { return createClient(this.getProfile(p), 'client'); }

  /**
  * Retrieves profile
  * @param profileId endpoint profile id
  */
  @Get("{profileId}/profile")
  public getProducts(profileId: ProfileId): Profile {
    const p = this.getProfile(profileId)
    return {
      locale: p.locale, timezone: p.timezone, endpoint: "", products: p.products,
      trip: getValue(p, p => p.trip), radar: getValue(p, p => p.radar),
      reachableFrom: getValue(p, p => p.reachableFrom), lines: getValue(p, p => p.lines)
    };
  }

  // the following methods are generated by the script 'generate-controller-methods'

  // beginOfRange
  /**
  * Retrieves journeys
  * @param profileId endpoint profile id
  * @param from 
  * @param to 
  * @param departure departure date, undefined corresponds to Date.Now
  * @param results how many search results?
  * @param via let journeys pass this station
  * @param stopovers return stations on the way?
  * @param transfers Maximum nr of transfers. Default: Let HAFAS decide.
  * @param transferTime minimum time for a single transfer in minutes
  * @param accessibility 'none', 'partial' or 'complete'
  * @param bike only bike-friendly journeys
  * @param tickets return tickets? only available with some profiles
  * @param polylines return a shape for each leg?
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param remarks parse & expose hints & warnings?
  * @param walkingSpeed 'slow', 'normal', 'fast'
  * @param startWithWalking start with walking
  * @param language language to get results in
  * @param scheduledDays parse which days each journey is valid on
  */
  @Get("{profileId}/journeys")
  public async getjourneys(
    profileId: ProfileId,
    @Query() from: string,
    @Query() to: string,
    @Query() departure = undefined,
    @Query() results = 3,
    @Query() via = undefined,
    @Query() stopovers = false,
    @Query() transfers = 10,
    @Query() transferTime = 10,
    @Query() accessibility = undefined,
    @Query() bike = false,
    @Query() tickets = false,
    @Query() polylines = false,
    @Query() subStops = false,
    @Query() entrances = true,
    @Query() remarks = true,
    @Query() walkingSpeed = "slow",
    @Query() startWithWalking = false,
    @Query() language = "en",
    @Query() scheduledDays = false,
  ): Promise<Journeys> {
    const client = this.clientFactory(profileId);
    return await client.journeys(from, to, { departure, results, via, stopovers, transfers, transferTime, accessibility, bike, tickets, polylines, subStops, entrances, remarks, walkingSpeed, startWithWalking, language, scheduledDays }) as Journeys;
  }
  /**
  * Refetch information about a trip
  * @param profileId endpoint profile id
  * @param id 
  * @param stopovers return stations on the way?
  * @param polyline return a shape for the trip?
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param remarks parse & expose hints & warnings?
  * @param scheduledDays parse which days each journey is valid on
  * @param language Language of the results
  */
  @Get("{profileId}/trip")
  public async gettrip(
    profileId: ProfileId,
    @Query() id: string,
    @Query() stopovers = true,
    @Query() polyline = false,
    @Query() subStops = true,
    @Query() entrances = true,
    @Query() remarks = true,
    @Query() scheduledDays = false,
    @Query() language = "en",
  ): Promise<TripWithRealtimeData> {
    const client = this.clientFactory(profileId);
    if (client.trip) return await client.trip(id, { stopovers, polyline, subStops, entrances, remarks, scheduledDays, language }) as TripWithRealtimeData; else throw ReferenceError("method not defined");
  }
  /**
  * Retrieves departures
  * @param profileId endpoint profile id
  * @param station 
  * @param when departure date, undefined corresponds to Date.Now
  * @param direction only show departures heading to this station
  * @param line filter by line ID
  * @param duration show departures for the next n minutes
  * @param results max. number of results; `null` means "whatever HAFAS wants"
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param linesOfStops parse & expose lines at the stop/station?
  * @param remarks parse & expose hints & warnings?
  * @param products products
  * @param language language
  */
  @Get("{profileId}/departures")
  public async getdepartures(
    profileId: ProfileId,
    @Query() station: string,
    @Query() when = undefined,
    @Query() direction = undefined,
    @Query() line = undefined,
    @Query() duration = 120,
    @Query() results = 10,
    @Query() subStops = true,
    @Query() entrances = true,
    @Query() linesOfStops = false,
    @Query() remarks = false,
    @Query() products = undefined,
    @Query() language = "en",
  ): Promise<Departures> {
    const client = this.clientFactory(profileId);
    return await client.departures(station, { when, direction, line, duration, results, subStops, entrances, linesOfStops, remarks, products, language }) as Departures;
  }
  /**
  * Retrieves locations or stops
  * @param profileId endpoint profile id
  * @param name 
  * @param fuzzy find only exact matches?
  * @param results how many search results?
  * @param stops return stops/stations?
  * @param addresses return addresses
  * @param poi points of interest
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param linesOfStops parse & expose lines at each stop/station?
  * @param language Language of the results
  */
  @Get("{profileId}/locations")
  public async getlocations(
    profileId: ProfileId,
    @Query() name: string,
    @Query() fuzzy = true,
    @Query() results = 10,
    @Query() stops = true,
    @Query() addresses = false,
    @Query() poi = true,
    @Query() subStops = false,
    @Query() entrances = true,
    @Query() linesOfStops = false,
    @Query() language = "en",
  ): Promise<Array<Station | Stop | Location>> {
    const client = this.clientFactory(profileId);
    return await client.locations(name, { fuzzy, results, stops, addresses, poi, subStops, entrances, linesOfStops, language }) as Array<Station | Stop | Location>;
  }
  /**
  * Retrieves information about a stop
  * @param profileId endpoint profile id
  * @param id 
  * @param linesOfStops parse & expose lines at the stop/station?
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param remarks parse & expose hints & warnings?
  * @param language Language of the results
  */
  @Get("{profileId}/stop")
  public async getstop(
    profileId: ProfileId,
    @Query() id: string,
    @Query() linesOfStops = false,
    @Query() subStops = true,
    @Query() entrances = true,
    @Query() remarks = true,
    @Query() language = "en",
  ): Promise<Station | Stop | Location> {
    const client = this.clientFactory(profileId);
    return await client.stop(id, { linesOfStops, subStops, entrances, remarks, language }) as Station | Stop | Location;
  }
  /**
  * Fetches all lines known to the HAFAS endpoint
  * @param profileId endpoint profile id
  * @param query 
  * @param language Language of the results
  */
  @Get("{profileId}/lines")
  public async getlines(
    profileId: ProfileId,
    @Query() query: string,
    @Query() language = "en",
  ): Promise<LinesWithRealtimeData> {
    const client = this.clientFactory(profileId);
    if (client.lines) return await client.lines(query, { language }) as LinesWithRealtimeData; else throw ReferenceError("method not defined");
  }
  /**
  * Retrieves nearby stops from location
  * @param profileId endpoint profile id
  * @param longitude 
  * @param latitude 
  * @param results maximum number of results
  * @param distance maximum walking distance in meters
  * @param poi return points of interest?
  * @param stops return stops/stations?
  * @param products products
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param linesOfStops parse & expose lines at each stop/station?
  * @param language language
  */
  @Get("{profileId}/nearby")
  public async getnearby(
    profileId: ProfileId,
    @Query() longitude: number,
    @Query() latitude: number,
    @Query() results = 8,
    @Query() distance = undefined,
    @Query() poi = false,
    @Query() stops = true,
    @Query() products = undefined,
    @Query() subStops = true,
    @Query() entrances = true,
    @Query() linesOfStops = false,
    @Query() language = "en",
  ): Promise<Array<Station | Stop | Location>> {
    const client = this.clientFactory(profileId);
    return await client.nearby({ type: "location", longitude, latitude }, { results, distance, poi, stops, products, subStops, entrances, linesOfStops, language }) as Array<Station | Stop | Location>;
  }
  /**
  * Retrieves stations reachable within a certain time from a location
  * @param profileId endpoint profile id
  * @param address 
  * @param longitude 
  * @param latitude 
  * @param distance 
  * @param maxTransfers maximum of transfers
  * @param maxDuration maximum travel duration in minutes, pass `null` for infinite
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param polylines return leg shapes?
  */
  @Get("{profileId}/reachableFrom")
  public async getreachableFrom(
    profileId: ProfileId,
    @Query() address: string,
    @Query() longitude: number,
    @Query() latitude: number,
    @Query() distance: number,
    @Query() maxTransfers = 5,
    @Query() maxDuration = 20,
    @Query() subStops = true,
    @Query() entrances = true,
    @Query() polylines = false,
  ): Promise<DurationsWithRealtimeData> {
    const client = this.clientFactory(profileId);
    if (client.reachableFrom) return await client.reachableFrom({ type: "location", address, longitude, latitude, distance }, { maxTransfers, maxDuration, subStops, entrances, polylines }) as DurationsWithRealtimeData; else throw ReferenceError("method not defined");
  }
  /**
  * Retrieves all vehicles currently in an area.
  * @param profileId endpoint profile id
  * @param north 
  * @param west 
  * @param south 
  * @param east 
  * @param results maximum number of vehicles
  * @param frames nr of frames to compute
  * @param duration compute frames for the next n seconds
  * @param subStops parse & expose sub-stops of stations?
  * @param entrances parse & expose entrances of stops/stations?
  * @param polylines return a shape for the trip?
  * @param when when
  */
  @Get("{profileId}/radar")
  public async getradar(
    profileId: ProfileId,
    @Query() north: number,
    @Query() west: number,
    @Query() south: number,
    @Query() east: number,
    @Query() results = 256,
    @Query() frames = 3,
    @Query() duration = 20,
    @Query() subStops = true,
    @Query() entrances = true,
    @Query() polylines = false,
    @Query() when = undefined,
  ): Promise<Radar> {
    const client = this.clientFactory(profileId);
    if (client.radar) return await client.radar({ north, west, south, east }, { results, frames, duration, subStops, entrances, polylines, when }) as Radar; else throw ReferenceError("method not defined");
  }
  // endOfRange
}