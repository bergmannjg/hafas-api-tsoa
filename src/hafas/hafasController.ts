import { Controller, Get, Query, Route } from "tsoa";
import createClient = require('hafas-client');
import dbProfile = require('hafas-client/p/db');
import { Stop, Location, Station, Journeys, Alternative, Trip, Duration, Movement } from './hafas-client-types';

@Route("hafas")
export class HafasController extends Controller {
  private clientFactory() { return createClient(dbProfile, 'client'); }

  // the following methods are generated by the script 'generate-controller-methods'

  // beginOfRange
/**
* Retrieves journeys
* @param from uid of station
* @param to uid of station
* @param departure departure date, undefined corresponds to Date.Now
* @param results how many search results?
* @param via let journeys pass this station
* @param stopovers return stations on the way?
* @param transfers Maximum nr of transfers. Default: Let HAFAS decide.
* @param transferTime minimum time for a single transfer in minutes
* @param accessibility 'none', 'partial' or 'complete'
* @param bike only bike-friendly journeys
* @param tickets return tickets? only available with some profiles
* @param polylines return a shape for each leg?
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
* @param remarks parse & expose hints & warnings?
* @param walkingSpeed 'slow', 'normal', 'fast'
* @param startWithWalking start with walking
* @param language language to get results in
* @param scheduledDays parse which days each journey is valid on
*/
@Get("journeys")
public async getjourneys(
@Query() from: string,
@Query() to: string,
@Query() departure = undefined,
@Query() results = 3,
@Query() via = undefined,
@Query() stopovers = false,
@Query() transfers = 10,
@Query() transferTime = 10,
@Query() accessibility = "none",
@Query() bike = false,
@Query() tickets = false,
@Query() polylines = false,
@Query() subStops = false,
@Query() entrances = true,
@Query() remarks = true,
@Query() walkingSpeed = "slow",
@Query() startWithWalking = false,
@Query() language = "en",
@Query() scheduledDays = false,
): Promise<Journeys> {
const client = this.clientFactory();
return await client.journeys(from, to, { departure, results, via, stopovers, transfers, transferTime, accessibility, bike, tickets, polylines, subStops, entrances, remarks, walkingSpeed, startWithWalking, language, scheduledDays }) as Journeys;
}
/**
* Refetch information about a trip
* @param id trip id, see {@link Leg#tripId}
* @param name name
* @param stopovers return stations on the way?
* @param polyline return a shape for the trip?
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
* @param remarks parse & expose hints & warnings?
* @param language Language of the results
*/
@Get("trip")
public async gettrip(
@Query() id: string,
@Query() name: string,
@Query() stopovers = true,
@Query() polyline = false,
@Query() subStops = true,
@Query() entrances = true,
@Query() remarks = true,
@Query() language = "en",
): Promise<Trip|{}> {
const client = this.clientFactory();
return client.trip ? await client.trip(id, name, { stopovers, polyline, subStops, entrances, remarks, language }) as Trip:{};
}
/**
* Retrieves departures
* @param station uid of station
* @param when departure date, undefined corresponds to Date.Now
* @param direction only show departures heading to this station
* @param duration show departures for the next n minutes
* @param results max. number of results; `null` means "whatever HAFAS wants"
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
* @param linesOfStops parse & expose lines at the stop/station?
* @param remarks parse & expose hints & warnings?
* @param stopovers fetch & parse previous/next stopovers?
* @param includeRelatedStations departures at related stations
* @param language language
*/
@Get("departures")
public async getdepartures(
@Query() station: string,
@Query() when = undefined,
@Query() direction = undefined,
@Query() duration = 120,
@Query() results = 10,
@Query() subStops = true,
@Query() entrances = true,
@Query() linesOfStops = false,
@Query() remarks = false,
@Query() stopovers = false,
@Query() includeRelatedStations = false,
@Query() language = "en",
): Promise<Array<Alternative>> {
const client = this.clientFactory();
return await client.departures(station, { when, direction, duration, results, subStops, entrances, linesOfStops, remarks, stopovers, includeRelatedStations, language }) as Array<Alternative>;
}
/**
* Retrieves locations or stops
* @param name name of station
* @param fuzzy find only exact matches?
* @param results how many search results?
* @param stops return stops/stations?
* @param addresses return addresses
* @param poi points of interest
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
* @param linesOfStops parse & expose lines at each stop/station?
* @param language Language of the results
*/
@Get("locations")
public async getlocations(
@Query() name: string,
@Query() fuzzy = true,
@Query() results = 10,
@Query() stops = true,
@Query() addresses = false,
@Query() poi = true,
@Query() subStops = false,
@Query() entrances = true,
@Query() linesOfStops = false,
@Query() language = "en",
): Promise<Array<Station | Stop | Location>> {
const client = this.clientFactory();
return await client.locations(name, { fuzzy, results, stops, addresses, poi, subStops, entrances, linesOfStops, language }) as Array<Station | Stop | Location>;
}
/**
* Retrieves information about a stop
* @param id uid of station
* @param linesOfStops parse & expose lines at the stop/station?
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
* @param remarks parse & expose hints & warnings?
* @param language Language of the results
*/
@Get("stop")
public async getstop(
@Query() id: string,
@Query() linesOfStops = false,
@Query() subStops = true,
@Query() entrances = true,
@Query() remarks = true,
@Query() language = "en",
): Promise<Station | Stop | Location> {
const client = this.clientFactory();
return await client.stop(id, { linesOfStops, subStops, entrances, remarks, language }) as Station | Stop | Location;
}
/**
* Retrieves nearby stops from location
* @param longitude 
* @param latitude 
* @param results maximum number of results
* @param distance maximum walking distance in meters
* @param poi return points of interest?
* @param stops return stops/stations?
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
* @param linesOfStops parse & expose lines at each stop/station?
* @param language language
*/
@Get("nearby")
public async getnearby(
@Query() longitude: number,
@Query() latitude: number,
@Query() results = 8,
@Query() distance = undefined,
@Query() poi = false,
@Query() stops = true,
@Query() subStops = true,
@Query() entrances = true,
@Query() linesOfStops = false,
@Query() language = "en",
): Promise<Array<Station | Stop | Location>> {
const client = this.clientFactory();
return await client.nearby({ type: "location", longitude, latitude }, { results, distance, poi, stops, subStops, entrances, linesOfStops, language }) as Array<Station | Stop | Location>;
}
/**
* Retrieves stations reachable within a certain time from a location
* @param address 
* @param longitude 
* @param latitude 
* @param distance 
* @param maxTransfers maximum of transfers
* @param maxDuration maximum travel duration in minutes, pass `null` for infinite
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
*/
@Get("reachableFrom")
public async getreachableFrom(
@Query() address: string,
@Query() longitude: number,
@Query() latitude: number,
@Query() distance: number,
@Query() maxTransfers = 5,
@Query() maxDuration = 20,
@Query() subStops = true,
@Query() entrances = true,
): Promise<Array<Duration>|{}> {
const client = this.clientFactory();
return client.reachableFrom ? await client.reachableFrom({ type: "location", address, longitude, latitude, distance }, { maxTransfers, maxDuration, subStops, entrances }) as Array<Duration>:{};
}
/**
* Retrieves all vehicles currently in an area.
* @param north 
* @param west 
* @param south 
* @param east 
* @param results maximum number of vehicles
* @param frames nr of frames to compute
* @param duration compute frames for the next n seconds
* @param subStops parse & expose sub-stops of stations?
* @param entrances parse & expose entrances of stops/stations?
* @param polylines return a shape for the trip?
* @param when when
*/
@Get("radar")
public async getradar(
@Query() north: number,
@Query() west: number,
@Query() south: number,
@Query() east: number,
@Query() results = 256,
@Query() frames = 3,
@Query() duration = 20,
@Query() subStops = true,
@Query() entrances = true,
@Query() polylines = false,
@Query() when = undefined,
): Promise<Array<Movement>|{}> {
const client = this.clientFactory();
return client.radar ? await client.radar({ north, west, south, east }, { results, frames, duration, subStops, entrances, polylines, when }) as Array<Movement>:{};
}
  // endOfRange
}